#!/usr/bin/env python3
"""
Enhanced FCD Data Generator with Road Networks and Junctions
============================================================

Generates realistic FCD files with:
- Multiple road types: straight roads, junctions, curves
- Complex road network topology
- Junction-aware vehicle routing
- Realistic intersection behavior
- All existing functionality preserved

Perfect for reinforcement learning training with realistic road scenarios.
"""

import numpy as np
import xml.etree.ElementTree as ET
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.animation as animation
from typing import Dict, List, Tuple, Optional, Union
import random
import math
import json
from datetime import datetime
from enum import Enum
from dataclasses import dataclass
from abc import ABC, abstractmethod

# ============================================================================
# NEW CLASSES FOR ROAD NETWORK SUPPORT
# ============================================================================

class RoadType(Enum):
    """Different types of road elements"""
    STRAIGHT = "straight"
    JUNCTION = "junction" 
    CURVE = "curve"
    ROUNDABOUT = "roundabout"

class Direction(Enum):
    """Cardinal directions for road orientation"""
    NORTH = 0
    EAST = 90
    SOUTH = 180
    WEST = 270

@dataclass
class Point:
    """2D point with utility methods"""
    x: float
    y: float
    
    def distance_to(self, other: 'Point') -> float:
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)
    
    def angle_to(self, other: 'Point') -> float:
        return math.atan2(other.y - self.y, other.x - self.x)

class RoadGeometry(ABC):
    """Abstract base class for road geometries"""
    
    @abstractmethod
    def get_position_at_distance(self, distance: float) -> Point:
        """Get x,y position at given distance along the road"""
        pass
    
    @abstractmethod
    def get_angle_at_distance(self, distance: float) -> float:
        """Get vehicle angle at given distance along the road"""
        pass
    
    @abstractmethod
    def get_length(self) -> float:
        """Get total length of the road"""
        pass

class StraightRoadGeometry(RoadGeometry):
    """Geometry for straight roads"""
    
    def __init__(self, start_point: Point, end_point: Point):
        self.start = start_point
        self.end = end_point
        self.length = start_point.distance_to(end_point)
        self.angle = start_point.angle_to(end_point)
    
    def get_position_at_distance(self, distance: float) -> Point:
        if distance <= 0:
            return self.start
        if distance >= self.length:
            return self.end
        
        ratio = distance / self.length
        x = self.start.x + (self.end.x - self.start.x) * ratio
        y = self.start.y + (self.end.y - self.start.y) * ratio
        return Point(x, y)
    
    def get_angle_at_distance(self, distance: float) -> float:
        return math.degrees(self.angle)
    
    def get_length(self) -> float:
        return self.length

class CurvedRoadGeometry(RoadGeometry):
    """Geometry for curved roads"""
    
    def __init__(self, start_point: Point, end_point: Point, control_point: Point):
        self.start = start_point
        self.end = end_point
        self.control = control_point
        self.length = self._calculate_curve_length()
    
    def _calculate_curve_length(self) -> float:
        # Approximate curve length using multiple segments
        segments = 20
        total_length = 0
        for i in range(segments):
            t1 = i / segments
            t2 = (i + 1) / segments
            p1 = self._bezier_point(t1)
            p2 = self._bezier_point(t2)
            total_length += p1.distance_to(p2)
        return total_length
    
    def _bezier_point(self, t: float) -> Point:
        """Get point on quadratic Bezier curve"""
        x = (1-t)**2 * self.start.x + 2*(1-t)*t * self.control.x + t**2 * self.end.x
        y = (1-t)**2 * self.start.y + 2*(1-t)*t * self.control.y + t**2 * self.end.y
        return Point(x, y)
    
    def get_position_at_distance(self, distance: float) -> Point:
        if distance <= 0:
            return self.start
        if distance >= self.length:
            return self.end
        
        # Convert distance to parameter t (0 to 1)
        t = distance / self.length
        return self._bezier_point(t)
    
    def get_angle_at_distance(self, distance: float) -> float:
        # Get tangent direction at this point
        t = min(1.0, max(0.0, distance / self.length))
        
        # Derivative of Bezier curve
        dx = 2*(1-t)*(self.control.x - self.start.x) + 2*t*(self.end.x - self.control.x)
        dy = 2*(1-t)*(self.control.y - self.start.y) + 2*t*(self.end.y - self.control.y)
        
        return math.degrees(math.atan2(dy, dx))
    
    def get_length(self) -> float:
        return self.length

class Road:
    """Represents a road segment with geometry and lanes"""
    
    def __init__(self, road_id: str, geometry: RoadGeometry, lanes_per_direction: int = 1,
                 lane_width: float = 3.7, speed_limit_kmh: float = 50):
        self.id = road_id
        self.geometry = geometry
        self.lanes_per_direction = lanes_per_direction
        self.total_lanes = lanes_per_direction * 2
        self.lane_width = lane_width
        self.speed_limit_kmh = speed_limit_kmh
        self.speed_limit_ms = speed_limit_kmh / 3.6
        
        # Connections to other roads/junctions
        self.connections_start: List['Road'] = []
        self.connections_end: List['Road'] = []
        
        # Traffic state
        self.vehicles_on_road: List['Vehicle'] = []
    
    def get_lane_center_position(self, lane_number: int, distance: float) -> Point:
        """Get the center position of a lane at given distance"""
        # Get road centerline position
        center_pos = self.geometry.get_position_at_distance(distance)
        road_angle = math.radians(self.geometry.get_angle_at_distance(distance))
        
        # Calculate lane offset from centerline
        total_width = self.total_lanes * self.lane_width
        lane_offset = (lane_number - (self.total_lanes + 1) / 2) * self.lane_width
        
        # Apply perpendicular offset
        perpendicular_angle = road_angle + math.pi / 2
        offset_x = lane_offset * math.cos(perpendicular_angle)
        offset_y = lane_offset * math.sin(perpendicular_angle)
        
        return Point(center_pos.x + offset_x, center_pos.y + offset_y)
    
    def get_lane_id(self, lane_number: int) -> str:
        """Get SUMO-style lane ID"""
        return f"{self.id}_{lane_number - 1}"

class Junction:
    """Represents a road junction/intersection"""
    
    def __init__(self, junction_id: str, center: Point, radius: float = 20.0):
        self.id = junction_id
        self.center = center
        self.radius = radius
        self.incoming_roads: List[Road] = []
        self.outgoing_roads: List[Road] = []
        self.connection_matrix: Dict[Tuple[str, int], List[Tuple[str, int]]] = {}
        
        # Junction control (traffic lights, etc.)
        self.has_traffic_light = False
        self.light_cycle_time = 60.0  # seconds
        self.current_phase = 0
        self.phase_start_time = 0.0
    
    def add_road_connection(self, from_road: Road, from_lane: int, 
                          to_road: Road, to_lane: int):
        """Add a connection from one road/lane to another through this junction"""
        from_key = (from_road.id, from_lane)
        to_key = (to_road.id, to_lane)
        
        if from_key not in self.connection_matrix:
            self.connection_matrix[from_key] = []
        self.connection_matrix[from_key].append(to_key)
    
    def get_possible_destinations(self, from_road_id: str, from_lane: int) -> List[Tuple[str, int]]:
        """Get possible destinations from a given road and lane"""
        key = (from_road_id, from_lane)
        return self.connection_matrix.get(key, [])
    
    def is_movement_allowed(self, from_road_id: str, to_road_id: str, current_time: float) -> bool:
        """Check if movement is currently allowed (considering traffic lights)"""
        if not self.has_traffic_light:
            return True
        
        # Simple traffic light logic - can be enhanced
        cycle_position = (current_time - self.phase_start_time) % self.light_cycle_time
        
        # Determine current phase based on cycle position
        green_time = self.light_cycle_time * 0.6  # 60% green
        if cycle_position < green_time / 2:
            allowed_phase = 0  # North-South
        elif cycle_position < green_time:
            allowed_phase = 1  # East-West
        else:
            return False  # Red/Yellow phase
        
        # Simple phase assignment based on road directions
        # This would need to be more sophisticated for real applications
        return True

class RoadNetwork:
    """Manages the complete road network"""
    
    def __init__(self):
        self.roads: Dict[str, Road] = {}
        self.junctions: Dict[str, Junction] = {}
        self.bounds = {'min_x': 0, 'max_x': 1000, 'min_y': 0, 'max_y': 1000}
    
    def add_road(self, road: Road):
        """Add a road to the network"""
        self.roads[road.id] = road
        self._update_bounds(road)
    
    def add_junction(self, junction: Junction):
        """Add a junction to the network"""
        self.junctions[junction.id] = junction
    
    def connect_roads(self, road1_id: str, road2_id: str, junction_id: str):
        """Connect two roads through a junction"""
        if all(key in self.roads for key in [road1_id, road2_id]) and junction_id in self.junctions:
            junction = self.junctions[junction_id]
            road1 = self.roads[road1_id]
            road2 = self.roads[road2_id]
            
            # Add to junction's road lists
            if road1 not in junction.incoming_roads:
                junction.incoming_roads.append(road1)
            if road2 not in junction.outgoing_roads:
                junction.outgoing_roads.append(road2)
            
            # Add to road connections
            road1.connections_end.append(road2)
            road2.connections_start.append(road1)
    
    def _update_bounds(self, road: Road):
        """Update network bounds based on road geometry"""
        # Sample multiple points along the road to get bounds
        samples = 10
        for i in range(samples + 1):
            distance = (i / samples) * road.geometry.get_length()
            pos = road.geometry.get_position_at_distance(distance)
            
            self.bounds['min_x'] = min(self.bounds['min_x'], pos.x - 50)
            self.bounds['max_x'] = max(self.bounds['max_x'], pos.x + 50)
            self.bounds['min_y'] = min(self.bounds['min_y'], pos.y - 50)
            self.bounds['max_y'] = max(self.bounds['max_y'], pos.y + 50)
    
    def get_network_bounds(self) -> Dict[str, float]:
        """Get the bounding box of the entire network"""
        return self.bounds.copy()
    
    def find_route(self, from_road_id: str, to_road_id: str) -> List[str]:
        """Simple routing between roads (can be enhanced with proper pathfinding)"""
        if from_road_id == to_road_id:
            return [from_road_id]
        
        # Simple BFS routing
        visited = set()
        queue = [(from_road_id, [from_road_id])]
        
        while queue:
            current_road_id, path = queue.pop(0)
            
            if current_road_id in visited:
                continue
            visited.add(current_road_id)
            
            if current_road_id == to_road_id:
                return path
            
            # Get connected roads
            if current_road_id in self.roads:
                current_road = self.roads[current_road_id]
                for connected_road in current_road.connections_end:
                    if connected_road.id not in visited:
                        queue.append((connected_road.id, path + [connected_road.id]))
        
        return [from_road_id]  # No route found, stay on current road

class RoadNetworkFactory:
    """Factory for creating common road network patterns"""
    
    @staticmethod
    def create_simple_intersection(center: Point, road_length: float = 200) -> RoadNetwork:
        """Create a simple 4-way intersection"""
        network = RoadNetwork()
        
        # Create junction
        junction = Junction("junction_0", center, radius=15.0)
        junction.has_traffic_light = True
        network.add_junction(junction)
        
        # Create four roads extending from center
        roads = []
        directions = [
            (Direction.NORTH, Point(center.x, center.y + road_length)),
            (Direction.SOUTH, Point(center.x, center.y - road_length)),
            (Direction.EAST, Point(center.x + road_length, center.y)),
            (Direction.WEST, Point(center.x - road_length, center.y))
        ]
        
        for i, (direction, end_point) in enumerate(directions):
            road_id = f"road_{direction.name.lower()}"
            geometry = StraightRoadGeometry(center, end_point)
            road = Road(road_id, geometry, lanes_per_direction=2)
            roads.append(road)
            network.add_road(road)
        
        # Set up junction connections for all possible turns
        for from_road in roads:
            for to_road in roads:
                if from_road != to_road:
                    # Add connections between compatible lanes
                    for from_lane in range(1, from_road.lanes_per_direction + 1):
                        for to_lane in range(from_road.lanes_per_direction + 1, 
                                           from_road.total_lanes + 1):
                            junction.add_road_connection(from_road, from_lane, to_road, to_lane)
        
        return network
    
    @staticmethod
    def create_highway_with_ramps(length: float = 1000) -> RoadNetwork:
        """Create a highway segment with on/off ramps"""
        network = RoadNetwork()
        
        # Main highway
        highway_start = Point(0, 100)
        highway_end = Point(length, 100)
        highway_geometry = StraightRoadGeometry(highway_start, highway_end)
        highway = Road("highway_main", highway_geometry, lanes_per_direction=3, speed_limit_kmh=120)
        network.add_road(highway)
        
        # On-ramp
        ramp_start = Point(200, 0)
        ramp_end = Point(300, 100)
        ramp_control = Point(250, 50)
        onramp_geometry = CurvedRoadGeometry(ramp_start, ramp_end, ramp_control)
        onramp = Road("onramp_1", onramp_geometry, lanes_per_direction=1, speed_limit_kmh=80)
        network.add_road(onramp)
        
        # Off-ramp
        offramp_start = Point(700, 100)
        offramp_end = Point(800, 0)
        offramp_control = Point(750, 50)
        offramp_geometry = CurvedRoadGeometry(offramp_start, offramp_end, offramp_control)
        offramp = Road("offramp_1", offramp_geometry, lanes_per_direction=1, speed_limit_kmh=80)
        network.add_road(offramp)
        
        # Create merge junctions
        merge_junction = Junction("merge_1", Point(300, 100), radius=10)
        exit_junction = Junction("exit_1", Point(700, 100), radius=10)
        
        network.add_junction(merge_junction)
        network.add_junction(exit_junction)
        
        # Connect roads
        network.connect_roads("onramp_1", "highway_main", "merge_1")
        network.connect_roads("highway_main", "offramp_1", "exit_1")
        
        return network
    
    @staticmethod
    def create_city_grid(grid_size: int = 3, block_size: float = 200) -> RoadNetwork:
        """Create a city grid network"""
        network = RoadNetwork()
        
        # Create grid of intersections
        junctions = {}
        for i in range(grid_size):
            for j in range(grid_size):
                junction_id = f"junction_{i}_{j}"
                center = Point(i * block_size, j * block_size)
                junction = Junction(junction_id, center)
                junction.has_traffic_light = True
                junctions[(i, j)] = junction
                network.add_junction(junction)
        
        # Create horizontal roads
        for i in range(grid_size):
            for j in range(grid_size - 1):
                road_id = f"h_road_{i}_{j}"
                start = Point(j * block_size, i * block_size)
                end = Point((j + 1) * block_size, i * block_size)
                geometry = StraightRoadGeometry(start, end)
                road = Road(road_id, geometry, lanes_per_direction=1, speed_limit_kmh=50)
                network.add_road(road)
                
                # Connect to junctions
                network.connect_roads(road_id, f"junction_{i}_{j+1}", f"junction_{i}_{j}")
        
        # Create vertical roads
        for i in range(grid_size - 1):
            for j in range(grid_size):
                road_id = f"v_road_{i}_{j}"
                start = Point(j * block_size, i * block_size)
                end = Point(j * block_size, (i + 1) * block_size)
                geometry = StraightRoadGeometry(start, end)
                road = Road(road_id, geometry, lanes_per_direction=1, speed_limit_kmh=50)
                network.add_road(road)
                
                # Connect to junctions
                network.connect_roads(road_id, f"junction_{i+1}_{j}", f"junction_{i}_{j}")
        
        return network

# ============================================================================
# REVISED CONFIGURATION CLASS
# ============================================================================

class FlexibleTrafficConfig:
    """Enhanced configuration with road network support"""
    
    @staticmethod
    def create_network_config(
        network_type: str = 'simple_intersection',
        vehicle_count: int = 30,
        speed_adaptation: bool = True,
        behavior_profile: str = 'normal',
        **network_params
    ) -> Dict:
        """Create configuration for road network scenarios"""
        return {
            'mode': 'road_network',
            'network_type': network_type,
            'network_params': network_params,
            'vehicle_count': vehicle_count,
            'speed_adaptation': speed_adaptation,
            'behavior_profile': behavior_profile,
            'spawn_pattern': 'network_aware',
            **network_params
        }
    
    # Keep all existing static methods unchanged
    @staticmethod
    def create_fixed_vehicle_config(
        vehicle_count: int = 45,
        speed_range_kmh: Tuple[float, float] = (18, 36),
        vehicle_types: Dict[str, float] = None,
        lane_distribution: str = 'balanced',
        spawn_pattern: str = 'continuous',
        behavior_profile: str = 'normal',
        **kwargs
    ) -> Dict:
        if vehicle_types is None:
            vehicle_types = {'car': 0.75, 'truck': 0.15, 'bus': 0.05, 'motorcycle': 0.05}
        
        return {
            'mode': 'fixed_count',
            'vehicle_count': vehicle_count,
            'speed_range_kmh': speed_range_kmh,
            'speed_range_ms': (speed_range_kmh[0] / 3.6, speed_range_kmh[1] / 3.6),
            'vehicle_types': vehicle_types,
            'lane_distribution': lane_distribution,
            'spawn_pattern': spawn_pattern,
            'behavior_profile': behavior_profile,
            'maintain_count': kwargs.get('maintain_count', True),
            'spawn_rate': kwargs.get('spawn_rate', 3),
            'speed_variation': kwargs.get('speed_variation', 0.2),
            **kwargs
        }
    
    @staticmethod
    def create_density_config(
        scenario: str = 'learning_optimized',
        density_factor: float = None,
        speed_adaptation: bool = True,
        **kwargs
    ) -> Dict:
        return {
            'mode': 'density_based',
            'scenario': scenario,
            'density_factor': density_factor,
            'speed_adaptation': speed_adaptation,
            **kwargs
        }
    
    @staticmethod
    def create_specific_nodes_config(
        node_mode: str = 'static',
        node_positions: Tuple[float, float] = (100.0, 300.0),
        node_speed_kmh: float = 30.0,
        lane_number: int = 1,
        duration: float = 300.0,
        node_types: Tuple[str, str] = ('car', 'car'),
        node_ids: Tuple[str, str] = ('node1', 'node2'),
        **kwargs
    ) -> Dict:
        return {
            'mode': 'specific_defined_nodes',
            'node_mode': node_mode,
            'node_positions': node_positions,
            'node_speed_kmh': node_speed_kmh,
            'node_speed_ms': node_speed_kmh / 3.6,
            'lane_number': lane_number,
            'duration': duration,
            'node_types': node_types,
            'node_ids': node_ids,
            'road_length': kwargs.get('road_length', 500.0),
            'enable_background_traffic': kwargs.get('enable_background_traffic', False),
            'background_vehicle_count': kwargs.get('background_vehicle_count', 10),
            **kwargs
        }

# Keep TrafficScenario class unchanged
class TrafficScenario:
    """Defines different traffic scenarios with density patterns"""
    
    SCENARIOS = {
        'rush_hour': {
            'description': 'Morning/evening rush hour with high density periods',
            'base_density': 0.6,
            'peak_density': 1.0,
            'peak_periods': [(1800, 2700), (7200, 8100)],
            'speed_reduction': 0.4
        },
        'highway_congestion': {
            'description': 'Highway with periodic congestion waves',
            'base_density': 0.3,
            'peak_density': 0.9,
            'wave_frequency': 1800,
            'wave_duration': 600,
            'speed_reduction': 0.6
        },
        'city_traffic': {
            'description': 'Urban traffic with traffic light cycles',
            'base_density': 0.5,
            'peak_density': 0.8,
            'cycle_frequency': 120,
            'cycle_duration': 30,
            'speed_reduction': 0.3
        },
        'random_varying': {
            'description': 'Randomly varying density for diverse learning',
            'base_density': 0.4,
            'variation_amplitude': 0.4,
            'variation_frequency': 300,
            'speed_reduction': 0.5
        },
        'learning_optimized': {
            'description': 'Optimized for RL with gradual density changes',
            'phases': [
                {'duration': 2000, 'density': 0.2, 'description': 'Light traffic'},
                {'duration': 2000, 'density': 0.5, 'description': 'Moderate traffic'},
                {'duration': 2000, 'density': 0.8, 'description': 'Heavy traffic'},
                {'duration': 2000, 'density': 0.95, 'description': 'Congestion'},
                {'duration': 2000, 'density': 0.6, 'description': 'Recovery'},
            ]
        }
    }

# ============================================================================
# REVISED VEHICLE AND NODE CLASSES
# ============================================================================

class Vehicle:
    """Enhanced vehicle class with road network support"""
    
    def __init__(self, vehicle_id: str, current_road: str, lane: int, 
                 distance_on_road: float, initial_speed: float,
                 direction: str = 'forward', vehicle_type: str = 'car', 
                 behavior_profile: str = 'normal', road_network: RoadNetwork = None):
        self.id = vehicle_id
        self.current_road_id = current_road
        self.lane = lane
        self.distance_on_road = distance_on_road  # Distance along current road
        self.speed = initial_speed
        self.target_speed = initial_speed
        self.direction = direction
        self.vehicle_type = vehicle_type
        self.behavior_profile = behavior_profile
        self.road_network = road_network
        
        # Route planning
        self.route: List[str] = [current_road]  # List of road IDs to follow
        self.route_index = 0
        
        # Physical properties
        self.length = self._get_vehicle_length()
        self.max_acceleration, self.max_deceleration = self._get_acceleration_limits()
        self.active = True
        self.lane_change_cooldown = 0
        self.following_distance = self._get_following_distance()
        
        # Network navigation
        self.at_junction = False
        self.junction_decision_made = False
        
        # Position cache for visualization
        self._cached_position = None
        self._cached_angle = None
    
    def _get_vehicle_length(self) -> float:
        """Get vehicle length based on type"""
        lengths = {'car': 4.5, 'truck': 16.0, 'bus': 12.0, 'motorcycle': 2.2}
        return lengths.get(self.vehicle_type, 4.5)
    
    def _get_acceleration_limits(self) -> Tuple[float, float]:
        """Get acceleration limits based on vehicle type and behavior profile"""
        base_limits = {
            'car': (2.5, 4.5),
            'truck': (1.5, 3.5),
            'bus': (1.8, 4.0),
            'motorcycle': (3.0, 5.0)
        }
        
        base_accel, base_decel = base_limits.get(self.vehicle_type, (2.5, 4.5))
        
        if self.behavior_profile == 'aggressive':
            return base_accel * 1.3, base_decel * 1.2
        elif self.behavior_profile == 'conservative':
            return base_accel * 0.8, base_decel * 0.9
        else:
            return base_accel, base_decel
    
    def _get_following_distance(self) -> float:
        """Get following distance based on behavior profile"""
        base_distance = 20.0
        if self.behavior_profile == 'aggressive':
            return base_distance * 0.7
        elif self.behavior_profile == 'conservative':
            return base_distance * 1.4
        else:
            return base_distance
    
    def update_position_network(self, dt: float, current_time: float, nearby_vehicles: List, 
                               custom_speed_range: Tuple[float, float] = None):
        """Enhanced position update for road networks"""
        if not self.active or not self.road_network:
            return
        
        # Get current road
        if self.current_road_id not in self.road_network.roads:
            self.active = False
            return
        
        current_road = self.road_network.roads[self.current_road_id]
        
        # Update target speed based on road speed limit
        road_speed_limit = current_road.speed_limit_ms
        if custom_speed_range:
            min_speed, max_speed = custom_speed_range
            self.target_speed = min(road_speed_limit, max_speed)
        else:
            self.target_speed = road_speed_limit
        
        # Vehicle type speed characteristics
        type_factors = {'truck': 0.9, 'bus': 0.85, 'motorcycle': 1.1, 'car': 1.0}
        self.target_speed *= type_factors.get(self.vehicle_type, 1.0)
        
        # Car following behavior
        leader = self._find_leader_on_network(nearby_vehicles)
        if leader:
            gap = self._calculate_gap_network(leader)
            safe_speed = self._calculate_safe_speed(gap, leader.speed)
            self.target_speed = min(self.target_speed, safe_speed)
        
        # Smooth acceleration/deceleration
        speed_diff = self.target_speed - self.speed
        if speed_diff > 0:
            acceleration = min(self.max_acceleration, speed_diff / dt)
        else:
            acceleration = max(-self.max_deceleration, speed_diff / dt)
        
        self.speed = max(0, self.speed + acceleration * dt)
        
        # Update position along road
        self.distance_on_road += self.speed * dt
        
        # Check if reached end of current road
        if self.distance_on_road >= current_road.geometry.get_length():
            self._handle_road_transition(current_time)
        
        # Update cached position for visualization
        self._update_cached_position()
        
        # Handle lane change cooldown
        if self.lane_change_cooldown > 0:
            self.lane_change_cooldown -= dt
    
    def _find_leader_on_network(self, nearby_vehicles: List['Vehicle']) -> Optional['Vehicle']:
        """Find the leading vehicle on the road network"""
        same_road_same_lane = [v for v in nearby_vehicles 
                              if (v.current_road_id == self.current_road_id and 
                                  v.lane == self.lane and v.id != self.id and v.active)]
        
        # Find vehicle ahead on same road
        ahead_vehicles = [v for v in same_road_same_lane 
                         if v.distance_on_road > self.distance_on_road]
        
        if ahead_vehicles:
            return min(ahead_vehicles, key=lambda v: v.distance_on_road)
        return None
    
    def _calculate_gap_network(self, leader: 'Vehicle') -> float:
        """Calculate gap to leading vehicle on network"""
        if leader.current_road_id == self.current_road_id:
            return leader.distance_on_road - self.distance_on_road - leader.length
        return 100.0  # Large gap if on different roads
    
    def _calculate_safe_speed(self, gap: float, leader_speed: float) -> float:
        """Calculate safe speed based on gap and leader speed"""
        min_gap = 5.0
        desired_gap = self.following_distance
        
        if gap < min_gap:
            return 0.0
        elif gap < desired_gap:
            gap_factor = gap / desired_gap
            return leader_speed * gap_factor * 0.8
        else:
            return leader_speed * 1.1
    
    def _handle_road_transition(self, current_time: float):
        """Handle transition between roads at junctions"""
        current_road = self.road_network.roads[self.current_road_id]
        
        # Check if there are connected roads
        if not current_road.connections_end:
            # Dead end - deactivate vehicle
            self.active = False
            return
        
        # Simple routing - choose random connected road
        next_road = random.choice(current_road.connections_end)
        
        # Check junction permissions if applicable
        junction_allows = True
        for junction in self.road_network.junctions.values():
            if (current_road in junction.incoming_roads and 
                next_road in junction.outgoing_roads):
                junction_allows = junction.is_movement_allowed(
                    self.current_road_id, next_road.id, current_time)
                break
        
        if junction_allows:
            # Transition to next road
            self.current_road_id = next_road.id
            self.distance_on_road = 0.0
            
            # Update route if following a planned route
            if len(self.route) > self.route_index + 1:
                self.route_index += 1
        else:
            # Wait at junction
            self.distance_on_road = current_road.geometry.get_length() - 1.0
            self.speed = 0.0
    
    def _update_cached_position(self):
        """Update cached position and angle for efficient visualization"""
        if self.current_road_id in self.road_network.roads:
            current_road = self.road_network.roads[self.current_road_id]
            position = current_road.get_lane_center_position(self.lane, self.distance_on_road)
            angle = current_road.geometry.get_angle_at_distance(self.distance_on_road)
            
            self._cached_position = (position.x, position.y)
            self._cached_angle = angle
        else:
            self._cached_position = (0, 0)
            self._cached_angle = 0
    
    def get_position(self) -> Tuple[float, float]:
        """Get current x,y position"""
        if self._cached_position:
            return self._cached_position
        return (0, 0)
    
    def get_angle(self) -> float:
        """Get current vehicle angle"""
        if self._cached_angle is not None:
            return self._cached_angle
        return 0.0
    
    def get_lane_id(self) -> str:
        """Get SUMO-style lane ID"""
        return f"{self.current_road_id}_{self.lane - 1}"
    
    def set_route(self, route: List[str]):
        """Set a planned route for the vehicle"""
        self.route = route
        self.route_index = 0

# Keep SpecificNode class mostly unchanged, but add network support
class SpecificNode:
    """Enhanced specific node class with road network support"""
    
    def __init__(self, node_id: str, node_type: str, road_id: str, lane: int, 
                 config: Dict, road_network: RoadNetwork = None):
        self.id = node_id
        self.vehicle_type = node_type
        self.current_road_id = road_id
        self.lane = lane
        self.config = config
        self.road_network = road_network
        self.active = True
        self.length = self._get_vehicle_length()
        self.distance_on_road = 0.0
        self.speed = 0.0
        self.target_speed = 0.0
        
        # Position cache
        self._cached_position = None
        self._cached_angle = None
        
        # Initialize based on mode
        if config['node_mode'] == 'static':
            self._init_static_mode()
        elif config['node_mode'] == 'dynamic':
            self._init_dynamic_mode()
    
    def _get_vehicle_length(self) -> float:
        """Get vehicle length based on type"""
        lengths = {'car': 4.5, 'truck': 16.0, 'bus': 12.0, 'motorcycle': 2.2}
        return lengths.get(self.vehicle_type, 4.5)
    
    def _init_static_mode(self):
        """Initialize for static mode"""
        positions = self.config['node_positions']
        if self.id == self.config['node_ids'][0]:
            self.distance_on_road = positions[0]
        else:
            self.distance_on_road = positions[1]
        
        self.speed = 0.0
        self.target_speed = 0.0
        self.direction = 'static'
        self.phase = 'stationary'
    
    def _init_dynamic_mode(self):
        """Initialize for dynamic mode"""
        road_length = self.config['road_length']
        self.speed = self.config['node_speed_ms']
        self.target_speed = self.speed
        
        if self.id == self.config['node_ids'][0]:
            self.distance_on_road = 0.0
            self.direction = 'right'
        else:
            self.distance_on_road = road_length
            self.direction = 'left'
        
        self.phase = 'moving_to_center'
        self.meeting_point = road_length / 2.0
    
    def update_position(self, dt: float, current_time: float, other_node: Optional['SpecificNode'] = None):
        """Update node position"""
        if not self.active:
            return
        
        if self.config['node_mode'] == 'static':
            self._update_static_position(dt, current_time)
        elif self.config['node_mode'] == 'dynamic':
            self._update_dynamic_position(dt, current_time, other_node)
        
        self._update_cached_position()
    
    def _update_static_position(self, dt: float, current_time: float):
        """Update static node (no movement)"""
        self.speed = 0.0
        if current_time >= self.config['duration']:
            self.active = False
    
    def _update_dynamic_position(self, dt: float, current_time: float, other_node: Optional['SpecificNode']):
        """Update dynamic node with movement"""
        if self.phase == 'moving_to_center':
            if self.direction == 'right':
                self.distance_on_road += self.speed * dt
                if self.distance_on_road >= self.meeting_point:
                    self.distance_on_road = self.meeting_point
                    self.phase = 'at_center'
            else:  # direction == 'left'
                self.distance_on_road -= self.speed * dt
                if self.distance_on_road <= self.meeting_point:
                    self.distance_on_road = self.meeting_point
                    self.phase = 'at_center'
        
        elif self.phase == 'at_center':
            if other_node and other_node.phase == 'at_center':
                self.phase = 'returning'
                if self.direction == 'right':
                    self.direction = 'left'
                    self.target_position = 0.0
                else:
                    self.direction = 'right'
                    self.target_position = self.config['road_length']
        
        elif self.phase == 'returning':
            if self.direction == 'right':
                self.distance_on_road += self.speed * dt
                if self.distance_on_road >= self.target_position:
                    self.distance_on_road = self.target_position
                    self.phase = 'completed'
            else:
                self.distance_on_road -= self.speed * dt
                if self.distance_on_road <= self.target_position:
                    self.distance_on_road = self.target_position
                    self.phase = 'completed'
    
    def _update_cached_position(self):
        """Update cached position for visualization"""
        if self.road_network and self.current_road_id in self.road_network.roads:
            current_road = self.road_network.roads[self.current_road_id]
            position = current_road.get_lane_center_position(self.lane, self.distance_on_road)
            angle = current_road.geometry.get_angle_at_distance(self.distance_on_road)
            
            self._cached_position = (position.x, position.y)
            self._cached_angle = angle
        else:
            # Fallback for non-network mode
            self._cached_position = (self.distance_on_road, (self.lane - 1) * 3.7)
            self._cached_angle = 90.0 if self.direction == 'right' else 270.0
    
    def get_position(self) -> Tuple[float, float]:
        """Get current x,y position"""
        if self._cached_position:
            return self._cached_position
        return (0, 0)
    
    def get_angle(self) -> float:
        """Get vehicle angle"""
        if self._cached_angle is not None:
            return self._cached_angle
        return 90.0
    
    def get_lane_id(self) -> str:
        """Get SUMO-style lane ID"""
        return f"{self.current_road_id}_{self.lane - 1}"
    
    def is_journey_complete(self) -> bool:
        """Check if the node has completed its journey"""
        if self.config['node_mode'] == 'static':
            return False
        else:
            return hasattr(self, 'phase') and self.phase == 'completed'

# ============================================================================
# MAJOR REVISIONS TO MAIN GENERATOR CLASS
# ============================================================================

class ComprehensiveFCDGenerator:
    """Enhanced main class with road network support"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.vehicles: Dict[str, Vehicle] = {}
        self.specific_nodes: Dict[str, SpecificNode] = {}
        self.vehicle_counter = 0
        self.current_time = 0.0
        
        # Handle flexible configuration FIRST
        self.traffic_config = config.get('traffic_config', {})
        
        # Road network setup
        self.road_network: Optional[RoadNetwork] = None
        self.operation_mode = self.traffic_config.get('mode', 'density_based')
        
        # Initialize road network if needed
        if self.operation_mode == 'road_network':
            self._initialize_road_network()
        else:
            # Original setup for backward compatibility
            if self.operation_mode == 'specific_defined_nodes':
                self.road_length = self.traffic_config.get('road_length', 1000)
                self.simulation_duration = self.traffic_config.get('duration', 10000)
            else:
                self.road_length = config.get('road_length', 1000)
                self.simulation_duration = config.get('simulation_duration', 10000)
                
            self.num_lanes = config.get('num_lanes_per_direction', 3) * 2
        
        self.time_step = config.get('time_step', 1.0)
        
        # Set up scenario for density-based mode
        if self.operation_mode == 'density_based':
            scenario_name = self.traffic_config.get('scenario', 'learning_optimized')
            self.scenario = TrafficScenario.SCENARIOS.get(scenario_name)
        else:
            self.scenario = None
        
        # Initialize specific nodes if in specific_defined_nodes mode
        if self.operation_mode == 'specific_defined_nodes':
            self._initialize_specific_nodes()
        
        # Visualization
        self.enable_visualization = config.get('enable_visualization', False)
        self.fig = None
        self.ax = None
        self.vehicle_plots = {}
        
        # Statistics
        self.density_history = []
        self.speed_history = []
        self.vehicle_count_history = []
        self.node_distance_history = []
        self.node_phase_history = []
    
    def _initialize_road_network(self):
        """Initialize road network based on configuration"""
        traffic_config = self.traffic_config
        network_type = traffic_config.get('network_type', 'simple_intersection')
        network_params = traffic_config.get('network_params', {})
        
        if network_type == 'simple_intersection':
            center = Point(network_params.get('center_x', 300), 
                          network_params.get('center_y', 300))
            road_length = network_params.get('road_length', 200)
            self.road_network = RoadNetworkFactory.create_simple_intersection(center, road_length)
            
        elif network_type == 'highway_with_ramps':
            length = network_params.get('highway_length', 1000)
            self.road_network = RoadNetworkFactory.create_highway_with_ramps(length)
            
        elif network_type == 'city_grid':
            grid_size = network_params.get('grid_size', 3)
            block_size = network_params.get('block_size', 200)
            self.road_network = RoadNetworkFactory.create_city_grid(grid_size, block_size)
            
        else:
            # Default fallback
            self.road_network = RoadNetworkFactory.create_simple_intersection(Point(300, 300), 200)
        
        # Set bounds and duration from network
        bounds = self.road_network.get_network_bounds()
        self.road_length = bounds['max_x'] - bounds['min_x']
        self.simulation_duration = self.config.get('simulation_duration', 5000)
        self.num_lanes = 4  # Default for network mode
        
        print(f"Initialized {network_type} road network")
        print(f"Network bounds: {bounds}")
        print(f"Roads: {len(self.road_network.roads)}, Junctions: {len(self.road_network.junctions)}")
    
    def _initialize_specific_nodes(self):
        """Initialize specific nodes (existing logic)"""
        node_config = self.traffic_config
        node_ids = node_config.get('node_ids', ('node1', 'node2'))
        node_types = node_config.get('node_types', ('car', 'car'))
        lane_number = node_config.get('lane_number', 1)
        
        # For backward compatibility, create a simple road network
        if not self.road_network:
            center = Point(0, 0)
            end = Point(self.road_length, 0)
            geometry = StraightRoadGeometry(center, end)
            road = Road("main_road", geometry, lanes_per_direction=3)
            self.road_network = RoadNetwork()
            self.road_network.add_road(road)
        
        # Create the two specific nodes
        for i, (node_id, node_type) in enumerate(zip(node_ids, node_types)):
            road_id = list(self.road_network.roads.keys())[0]  # Use first road
            node = SpecificNode(node_id, node_type, road_id, lane_number, node_config, self.road_network)
            self.specific_nodes[node_id] = node
        
        print(f"Initialized {len(self.specific_nodes)} specific nodes")
    
    def generate_fcd(self, output_file: str):
        """Generate FCD with enhanced road network support"""
        mode_desc = f"{self.operation_mode} mode"
        
        if self.operation_mode == 'road_network':
            network_type = self.traffic_config.get('network_type', 'simple_intersection')
            vehicle_count = self.traffic_config.get('vehicle_count', 30)
            mode_desc += f" ({network_type}, {vehicle_count} vehicles)"
        elif self.operation_mode == 'fixed_count':
            target_count = self.traffic_config.get('vehicle_count', 45)
            speed_range = self.traffic_config.get('speed_range_kmh', (30, 120))
            mode_desc += f" ({target_count} vehicles, {speed_range[0]}-{speed_range[1]} km/h)"
        elif self.operation_mode == 'specific_defined_nodes':
            node_mode = self.traffic_config.get('node_mode', 'static')
            lane_num = self.traffic_config.get('lane_number', 1)
            mode_desc += f" ({node_mode} nodes, Lane {lane_num})"
        
        print(f"Starting FCD generation...")
        print(f"Configuration: {mode_desc}")
        print(f"Duration: {self.simulation_duration} seconds")
        
        if self.road_network:
            bounds = self.road_network.get_network_bounds()
            print(f"Network bounds: {bounds}")
        else:
            print(f"Road: {self.road_length}m with {self.num_lanes} lanes")
        
        # Setup visualization if enabled
        if self.enable_visualization:
            self._setup_visualization()
        
        # Create XML structure
        root = ET.Element('fcd-export')
        root.set('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance')
        root.set('xsi:noNamespaceSchemaLocation', 'http://sumo.dlr.de/xsd/fcd_file.xsd')
        
        # Simulation loop
        time_steps = np.arange(0, self.simulation_duration, self.time_step)
        
        for i, time in enumerate(time_steps):
            self.current_time = time
            
            # Handle different modes
            if self.operation_mode == 'road_network':
                self._manage_network_traffic()
                current_density = self._calculate_network_density()
                
            elif self.operation_mode == 'specific_defined_nodes':
                simulation_complete = self._update_specific_nodes()
                if self.traffic_config.get('enable_background_traffic', False):
                    self._manage_background_traffic()
                current_density = 0.1
                
                if simulation_complete and self.traffic_config['node_mode'] == 'dynamic':
                    if i > len(time_steps) - 10:
                        break
            else:
                # Original modes
                if self.operation_mode == 'fixed_count':
                    self._manage_fixed_vehicle_population()
                    current_density = self._calculate_effective_density()
                else:
                    current_density = self._calculate_traffic_density(time)
                    self._manage_vehicle_population(current_density)
            
            # Update all vehicles
            active_vehicles = [v for v in self.vehicles.values() if v.active]
            speed_range_ms = self.traffic_config.get('speed_range_ms') if self.operation_mode == 'fixed_count' else None
            
            all_moving_objects = active_vehicles + [node for node in self.specific_nodes.values() if node.active]
            
            for vehicle in active_vehicles:
                if self.road_network and hasattr(vehicle, 'update_position_network'):
                    vehicle.update_position_network(self.time_step, current_density, all_moving_objects, speed_range_ms)
                else:
                    vehicle.update_position(self.time_step, current_density, all_moving_objects, speed_range_ms)
                
                # Handle boundary conditions
                if self.operation_mode != 'road_network':
                    self._handle_boundary_conditions(vehicle)
            
            # Create timestep element
            timestep = ET.SubElement(root, 'timestep')
            timestep.set('time', f'{time:.2f}')
            
            # Add specific nodes data
            for node in self.specific_nodes.values():
                if node.active:
                    veh_elem = ET.SubElement(timestep, 'vehicle')
                    veh_elem.set('id', node.id)
                    x, y = node.get_position()
                    veh_elem.set('x', f'{x:.2f}')
                    veh_elem.set('y', f'{y:.2f}')
                    veh_elem.set('angle', f'{node.get_angle():.2f}')
                    veh_elem.set('type', 'SPECIFIC_NODE')
                    veh_elem.set('speed', f'{node.speed:.2f}')
                    veh_elem.set('pos', f'{x:.2f}')
                    veh_elem.set('lane', node.get_lane_id())
                    veh_elem.set('slope', '0.00')
            
            # Add regular vehicle data
            for vehicle in active_vehicles:
                if vehicle.active:
                    veh_elem = ET.SubElement(timestep, 'vehicle')
                    veh_elem.set('id', vehicle.id)
                    x, y = vehicle.get_position()
                    veh_elem.set('x', f'{x:.2f}')
                    veh_elem.set('y', f'{y:.2f}')
                    veh_elem.set('angle', f'{vehicle.get_angle():.2f}')
                    veh_elem.set('type', 'DEFAULT_VEHTYPE')
                    veh_elem.set('speed', f'{vehicle.speed:.2f}')
                    veh_elem.set('pos', f'{x:.2f}')
                    veh_elem.set('lane', vehicle.get_lane_id())
                    veh_elem.set('slope', '0.00')
            
            # Update statistics
            self._update_statistics(current_density, active_vehicles)
            
            # Update visualization
            if self.enable_visualization and i % 5 == 0:
                self._update_visualization(active_vehicles)
            
            # Progress reporting
            if i % 500 == 0:
                self._report_progress(i, len(time_steps), time, active_vehicles, current_density)
        
        # Write XML file
        tree = ET.ElementTree(root)
        ET.indent(tree, space="  ", level=0)
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        
        print(f"FCD data written to {output_file}")
        self._generate_statistics_report(output_file)
    
    def _manage_network_traffic(self):
        """Manage vehicle population in road network mode"""
        target_count = self.traffic_config.get('vehicle_count', 30)
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        current_count = len(active_vehicles)
        
        if current_count < target_count:
            vehicles_to_spawn = min(3, target_count - current_count)
            for _ in range(vehicles_to_spawn):
                self._spawn_network_vehicle()
        elif current_count > target_count * 1.2:
            vehicles_to_remove = min(2, current_count - target_count)
            despawnable = [v for v in active_vehicles if self._can_despawn_network(v)]
            for vehicle in random.sample(despawnable, min(vehicles_to_remove, len(despawnable))):
                vehicle.active = False
    
    def _spawn_network_vehicle(self):
        """Spawn a vehicle in the road network"""
        if not self.road_network or not self.road_network.roads:
            return
        
        # Choose a random road and lane
        road_id = random.choice(list(self.road_network.roads.keys()))
        road = self.road_network.roads[road_id]
        lane = random.randint(1, road.total_lanes)
        
        # Start at beginning of road
        distance_on_road = 0.0
        
        # Vehicle type and properties
        vehicle_type = random.choices(
            ['car', 'truck', 'bus', 'motorcycle'], 
            weights=[0.75, 0.15, 0.05, 0.05]
        )[0]
        
        initial_speed = random.uniform(road.speed_limit_ms * 0.7, road.speed_limit_ms)
        behavior_profile = self.traffic_config.get('behavior_profile', 'normal')
        
        vehicle_id = f'net_veh{self.vehicle_counter}'
        self.vehicle_counter += 1
        
        vehicle = Vehicle(vehicle_id, road_id, lane, distance_on_road, initial_speed,
                         'forward', vehicle_type, behavior_profile, self.road_network)
        self.vehicles[vehicle_id] = vehicle
    
    def _can_despawn_network(self, vehicle: Vehicle) -> bool:
        """Check if network vehicle can be despawned"""
        if not vehicle.road_network:
            return True
        
        # Check if vehicle is at the end of a road with no connections
        if vehicle.current_road_id in vehicle.road_network.roads:
            current_road = vehicle.road_network.roads[vehicle.current_road_id]
            at_end = vehicle.distance_on_road >= current_road.geometry.get_length() - 10
            no_connections = len(current_road.connections_end) == 0
            return at_end and no_connections
        
        return True
    
    def _calculate_network_density(self) -> float:
        """Calculate traffic density for network mode"""
        if not self.road_network:
            return 0.3
        
        total_road_length = sum(road.geometry.get_length() for road in self.road_network.roads.values())
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        
        if total_road_length > 0:
            vehicles_per_km = len(active_vehicles) / (total_road_length / 1000)
            # Map to density factor
            if vehicles_per_km <= 20:
                return 0.2
            elif vehicles_per_km <= 40:
                return 0.4
            elif vehicles_per_km <= 80:
                return 0.6
            else:
                return 0.8
        
        return 0.3
    
    def _setup_visualization(self):
        """Enhanced visualization setup for road networks"""
        self.fig = plt.figure(figsize=(16, 12))
        
        if self.operation_mode == 'road_network':
            # Full window for road network
            self.ax = plt.subplot2grid((1, 1), (0, 0))
            
            bounds = self.road_network.get_network_bounds()
            margin = 50
            self.ax.set_xlim(bounds['min_x'] - margin, bounds['max_x'] + margin)
            self.ax.set_ylim(bounds['min_y'] - margin, bounds['max_y'] + margin)
            self.ax.set_aspect('equal')
            self.ax.set_title('Road Network Traffic Simulation', fontsize=14, fontweight='bold')
            
            # Draw road network
            self._draw_road_network()
        else:
            # Original layout for other modes
            self.ax = plt.subplot2grid((4, 4), (0, 0), colspan=4, rowspan=3)
            self.stats_ax = plt.subplot2grid((4, 4), (3, 0), colspan=2)
            self.speed_ax = plt.subplot2grid((4, 4), (3, 2), colspan=2)
            
            if hasattr(self, 'road_length'):
                self.ax.set_xlim(-50, self.road_length + 50)
                self.ax.set_ylim(-2, self.num_lanes * 3.7 + 2)
            else:
                self.ax.set_xlim(-50, 1000)
                self.ax.set_ylim(-2, 20)
            
            self.ax.set_title('Traffic Simulation', fontsize=14, fontweight='bold')
            self._draw_road_infrastructure()
            self._setup_statistics_display()
        
        self.vehicle_plots = {}
        self.vehicle_labels = {}
        
        plt.tight_layout()
        plt.ion()
        plt.show()
    
    def _draw_road_network(self):
        """Draw the road network infrastructure"""
        if not self.road_network:
            return
        
        # Draw roads
        for road in self.road_network.roads.values():
            self._draw_single_road(road)
        
        # Draw junctions
        for junction in self.road_network.junctions.values():
            self._draw_junction(junction)
    
    def _draw_single_road(self, road: Road):
        """Draw a single road with lanes"""
        geometry = road.geometry
        road_length = geometry.get_length()
        samples = max(20, int(road_length / 10))  # Sample every 10m or 20 samples minimum
        
        # Get road centerline points
        centerline_points = []
        for i in range(samples + 1):
            distance = (i / samples) * road_length
            pos = geometry.get_position_at_distance(distance)
            centerline_points.append((pos.x, pos.y))
        
        centerline_x = [p[0] for p in centerline_points]
        centerline_y = [p[1] for p in centerline_points]
        
        # Draw road base
        lane_width = road.lane_width
        total_width = road.total_lanes * lane_width
        
        # Create road polygon (simplified as centerline for now)
        self.ax.plot(centerline_x, centerline_y, color='#404040', linewidth=total_width * 2, 
                    solid_capstyle='round', alpha=0.8, zorder=0)
        
        # Draw lane dividers
        for lane_offset in range(-road.lanes_per_direction, road.lanes_per_direction + 1):
            if lane_offset == 0:
                # Center divider - double yellow
                self._draw_lane_line(geometry, lane_offset, lane_width, 'yellow', '--', 2, samples)
            else:
                # Lane dividers - white dashed
                self._draw_lane_line(geometry, lane_offset, lane_width, 'white', ':', 1, samples)
        
        # Add road label
        mid_point = geometry.get_position_at_distance(road_length / 2)
        self.ax.text(mid_point.x, mid_point.y - total_width/2 - 5, road.id, 
                    fontsize=8, ha='center', va='top',
                    bbox=dict(boxstyle="round,pad=0.2", facecolor='lightblue', alpha=0.7))
    
    def _draw_lane_line(self, geometry: RoadGeometry, lane_offset: int, lane_width: float,
                       color: str, linestyle: str, linewidth: int, samples: int):
        """Draw a lane line along the road geometry"""
        road_length = geometry.get_length()
        points = []
        
        for i in range(samples + 1):
            distance = (i / samples) * road_length
            center_pos = geometry.get_position_at_distance(distance)
            angle = math.radians(geometry.get_angle_at_distance(distance))
            
            # Calculate perpendicular offset
            perpendicular_angle = angle + math.pi / 2
            offset = lane_offset * lane_width
            offset_x = offset * math.cos(perpendicular_angle)
            offset_y = offset * math.sin(perpendicular_angle)
            
            points.append((center_pos.x + offset_x, center_pos.y + offset_y))
        
        if points:
            x_coords = [p[0] for p in points]
            y_coords = [p[1] for p in points]
            self.ax.plot(x_coords, y_coords, color=color, linestyle=linestyle, 
                        linewidth=linewidth, alpha=0.7, zorder=1)
    
    def _draw_junction(self, junction: Junction):
        """Draw a junction"""
        circle = patches.Circle((junction.center.x, junction.center.y), junction.radius,
                               facecolor='#606060', edgecolor='white', linewidth=2, 
                               alpha=0.9, zorder=2)
        self.ax.add_patch(circle)
        
        # Junction label
        self.ax.text(junction.center.x, junction.center.y, junction.id, 
                    fontsize=8, ha='center', va='center', color='white', fontweight='bold')
        
        # Traffic light indicator
        if junction.has_traffic_light:
            light_indicator = patches.Circle((junction.center.x + junction.radius * 0.7, 
                                            junction.center.y + junction.radius * 0.7), 
                                           3, facecolor='red', alpha=0.8, zorder=3)
            self.ax.add_patch(light_indicator)
    
    def _update_visualization(self, vehicles: List[Vehicle]):
        """Enhanced visualization update for road networks"""
        if not self.enable_visualization:
            return
        
        # Clear previous plots
        for plot in self.vehicle_plots.values():
            if isinstance(plot, list):
                for p in plot:
                    if hasattr(p, 'remove'):
                        p.remove()
            else:
                if hasattr(plot, 'remove'):
                    plot.remove()
        
        for label in self.vehicle_labels.values():
            if hasattr(label, 'remove'):
                label.remove()
        
        self.vehicle_plots.clear()
        self.vehicle_labels.clear()
        
        # Draw specific nodes
        for node in self.specific_nodes.values():
            if node.active:
                self._draw_specific_node_network(node)
        
        # Draw vehicles
        for vehicle in vehicles:
            if vehicle.active:
                self._draw_vehicle_network(vehicle)
        
        # Update title
        if self.operation_mode == 'road_network':
            title = f'Road Network Simulation | Time: {self.current_time:.0f}s | Vehicles: {len(vehicles)}'
            if vehicles:
                avg_speed = np.mean([v.speed for v in vehicles]) * 3.6
                title += f' | Avg Speed: {avg_speed:.1f} km/h'
        else:
            title = f'Traffic Simulation | Time: {self.current_time:.0f}s | Vehicles: {len(vehicles)}'
        
        self.ax.set_title(title, fontsize=12, fontweight='bold')
        
        plt.pause(0.001)
    
    def _draw_specific_node_network(self, node: SpecificNode):
        """Draw specific node in network mode"""
        x, y = node.get_position()
        
        # Node styling
        node_colors = {'car': '#FF1744', 'truck': '#D32F2F', 'bus': '#F57C00', 'motorcycle': '#8E24AA'}
        color = node_colors.get(node.vehicle_type, '#FF1744')
        
        node_plot = self.ax.scatter(x, y, c=color, marker='D', s=150, 
                                   alpha=0.9, edgecolors='white', linewidth=3, zorder=5)
        
        # Label
        speed_kmh = node.speed * 3.6
        label_text = f'{node.id}\n{speed_kmh:.0f} km/h'
        if hasattr(node, 'phase'):
            label_text += f'\n{node.phase}'
            
        label = self.ax.text(x, y - 8, label_text, 
                           fontsize=9, ha='center', va='top', fontweight='bold',
                           bbox=dict(boxstyle="round,pad=0.3", facecolor='yellow', alpha=0.9),
                           zorder=5)
        
        self.vehicle_plots[node.id] = node_plot
        self.vehicle_labels[node.id] = label
    
    def _draw_vehicle_network(self, vehicle: Vehicle):
        """Draw vehicle in network mode"""
        x, y = vehicle.get_position()
        
        # Vehicle styling
        vehicle_config = {
            'car': {'color': '#4CAF50', 'marker': 's', 'size': 60},
            'truck': {'color': '#F44336', 'marker': 's', 'size': 100},
            'bus': {'color': '#FF9800', 'marker': 's', 'size': 80},
            'motorcycle': {'color': '#9C27B0', 'marker': 'o', 'size': 40}
        }
        
        config = vehicle_config.get(vehicle.vehicle_type, vehicle_config['car'])
        
        vehicle_plot = self.ax.scatter(x, y, c=config['color'], 
                                     marker=config['marker'], s=config['size'], 
                                     alpha=0.8, edgecolors='black', linewidth=1, zorder=3)
        
        # Show vehicle ID and speed for some vehicles
        if len(self.vehicle_plots) < 15 or vehicle.id.endswith('0'):
            speed_kmh = vehicle.speed * 3.6
            label_text = f'{vehicle.id}\n{speed_kmh:.0f}'
            label = self.ax.text(x, y - 6, label_text, 
                               fontsize=7, ha='center', va='top',
                               bbox=dict(boxstyle="round,pad=0.2", facecolor='white', alpha=0.7),
                               zorder=4)
            self.vehicle_labels[vehicle.id] = label
        
        self.vehicle_plots[vehicle.id] = vehicle_plot

    # Keep all other existing methods unchanged...
    # (All the existing methods like _update_specific_nodes, _manage_fixed_vehicle_population, 
    #  _calculate_traffic_density, _generate_statistics_report, etc. remain the same)
    
    def _update_specific_nodes(self) -> bool:
        """Update specific nodes and return True if simulation should complete"""
        if not self.specific_nodes:
            return False
        
        nodes = list(self.specific_nodes.values())
        
        if len(nodes) == 2:
            nodes[0].update_position(self.time_step, self.current_time, nodes[1])
            nodes[1].update_position(self.time_step, self.current_time, nodes[0])
            
            if self.traffic_config['node_mode'] == 'dynamic':
                if hasattr(nodes[0], '_cached_position') and hasattr(nodes[1], '_cached_position'):
                    pos1 = nodes[0]._cached_position or (0, 0)
                    pos2 = nodes[1]._cached_position or (0, 0)
                    distance = math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)
                else:
                    distance = abs(nodes[0].distance_on_road - nodes[1].distance_on_road)
                
                self.node_distance_history.append(distance)
                phases = [getattr(node, 'phase', 'unknown') for node in nodes]
                self.node_phase_history.append(f"{phases[0]}-{phases[1]}")
                
                if all(node.is_journey_complete() for node in nodes):
                    return True
        else:
            nodes[0].update_position(self.time_step, self.current_time)
        
        return False
    
    def _manage_background_traffic(self):
        """Manage background traffic in specific nodes mode"""
        target_count = self.traffic_config.get('background_vehicle_count', 10)
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        current_count = len(active_vehicles)
        
        specific_node_lane = self.traffic_config.get('lane_number', 1)
        
        if current_count < target_count:
            vehicles_to_spawn = min(2, target_count - current_count)
            for _ in range(vehicles_to_spawn):
                self._spawn_background_vehicle(avoid_lane=specific_node_lane)
        elif current_count > target_count * 1.2:
            vehicles_to_remove = min(2, current_count - target_count)
            despawnable = [v for v in active_vehicles if self._can_despawn(v)]
            for vehicle in random.sample(despawnable, min(vehicles_to_remove, len(despawnable))):
                vehicle.active = False
    
    def _spawn_background_vehicle(self, avoid_lane: int = None):
        """Spawn a background vehicle avoiding specific lanes"""
        if self.road_network:
            self._spawn_network_vehicle()
            return
            
        direction = random.choice(['forward', 'backward'])
        
        if direction == 'forward':
            available_lanes = [l for l in range(1, self.num_lanes // 2 + 1) if l != avoid_lane]
        else:
            available_lanes = [l for l in range(self.num_lanes // 2 + 1, self.num_lanes + 1)]
        
        if not available_lanes:
            return
            
        lane = random.choice(available_lanes)
        
        if direction == 'forward':
            start_x = -50
        else:
            start_x = self.road_length + 50
        
        vehicle_type = random.choices(
            ['car', 'truck', 'bus', 'motorcycle'], 
            weights=[0.8, 0.1, 0.05, 0.05]
        )[0]
        
        initial_speed = random.uniform(1.0, 2.5)
        
        vehicle_id = f'bg_veh{self.vehicle_counter}'
        self.vehicle_counter += 1
        
        vehicle = Vehicle(vehicle_id, lane, start_x, initial_speed, direction, vehicle_type)
        self.vehicles[vehicle_id] = vehicle
    
    def _manage_fixed_vehicle_population(self):
        """Manage vehicle population for fixed count mode"""
        target_count = self.traffic_config.get('vehicle_count', 45)
        maintain_count = self.traffic_config.get('maintain_count', True)
        spawn_rate = self.traffic_config.get('spawn_rate', 3)
        
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        current_count = len(active_vehicles)
        
        if current_count < target_count:
            vehicles_to_spawn = min(spawn_rate, target_count - current_count)
            for _ in range(vehicles_to_spawn):
                if self.road_network:
                    self._spawn_network_vehicle()
                else:
                    self._spawn_vehicle_flexible()
        
        elif maintain_count and current_count > target_count * 1.15:
            vehicles_to_remove = min(2, current_count - target_count)
            if self.road_network:
                despawnable = [v for v in active_vehicles if self._can_despawn_network(v)]
            else:
                despawnable = [v for v in active_vehicles if self._can_despawn(v)]
            for vehicle in random.sample(despawnable, min(vehicles_to_remove, len(despawnable))):
                vehicle.active = False
    
    def _spawn_vehicle_flexible(self):
        """Spawn a vehicle with flexible configuration (original mode)"""
        vehicle_types = self.traffic_config.get('vehicle_types', 
                                               {'car': 0.75, 'truck': 0.15, 'bus': 0.05, 'motorcycle': 0.05})
        lane_distribution = self.traffic_config.get('lane_distribution', 'balanced')
        behavior_profile = self.traffic_config.get('behavior_profile', 'normal')
        speed_range_ms = self.traffic_config.get('speed_range_ms', (1.0, 3.0))
        speed_variation = self.traffic_config.get('speed_variation', 0.2)
        
        direction = random.choice(['forward', 'backward'])
        lane = self._choose_lane(direction, lane_distribution)
        
        if direction == 'forward':
            start_x = -50
        else:
            start_x = self.road_length + 50
        
        vehicle_type = random.choices(
            list(vehicle_types.keys()),
            weights=list(vehicle_types.values())
        )[0]
        
        base_speed = random.uniform(speed_range_ms[0], speed_range_ms[1])
        speed_var = random.uniform(1 - speed_variation, 1 + speed_variation)
        initial_speed = base_speed * speed_var
        
        type_factors = {'truck': 0.9, 'bus': 0.85, 'motorcycle': 1.1, 'car': 1.0}
        initial_speed *= type_factors.get(vehicle_type, 1.0)
        
        vehicle_id = f'veh{self.vehicle_counter}'
        self.vehicle_counter += 1
        
        vehicle = Vehicle(vehicle_id, lane, start_x, initial_speed, direction, vehicle_type, behavior_profile)
        self.vehicles[vehicle_id] = vehicle
    
    def _choose_lane(self, direction: str, distribution: str) -> int:
        """Choose lane based on distribution pattern"""
        if direction == 'forward':
            available_lanes = list(range(1, self.num_lanes // 2 + 1))
        else:
            available_lanes = list(range(self.num_lanes // 2 + 1, self.num_lanes + 1))
        
        if distribution == 'balanced':
            return random.choice(available_lanes)
        elif distribution == 'heavy_right':
            weights = [1.0 + i * 0.5 for i in range(len(available_lanes))]
            return random.choices(available_lanes, weights=weights)[0]
        elif distribution == 'heavy_left':
            weights = [1.0 + (len(available_lanes) - 1 - i) * 0.5 for i in range(len(available_lanes))]
            return random.choices(available_lanes, weights=weights)[0]
        else:
            return random.choice(available_lanes)
    
    def _calculate_effective_density(self) -> float:
        """Calculate effective density for fixed count mode"""
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        vehicle_count = len(active_vehicles)
        
        if self.road_network:
            total_road_length = sum(road.geometry.get_length() for road in self.road_network.roads.values())
            road_length_km = total_road_length / 1000.0 if total_road_length > 0 else 1.0
        else:
            road_length_km = self.road_length / 1000.0
        
        vehicles_per_direction = vehicle_count / 2
        vehicles_per_km_per_direction = vehicles_per_direction / road_length_km
        
        if vehicles_per_km_per_direction <= 30:
            return 0.1
        elif vehicles_per_km_per_direction <= 60:
            return 0.3
        elif vehicles_per_km_per_direction <= 120:
            return 0.5
        elif vehicles_per_km_per_direction <= 180:
            return 0.7
        else:
            return 0.9
    
    def _calculate_traffic_density(self, time: float) -> float:
        """Calculate traffic density based on scenario and time"""
        if not self.scenario:
            return 0.5
            
        scenario = self.scenario
        
        if 'phases' in scenario:
            cumulative_time = 0
            for phase in scenario['phases']:
                if time < cumulative_time + phase['duration']:
                    return phase['density']
                cumulative_time += phase['duration']
            return scenario['phases'][-1]['density']
        
        elif scenario.get('peak_periods'):
            density = scenario['base_density']
            for start, end in scenario['peak_periods']:
                if start <= time <= end:
                    peak_factor = 0.5 * (1 + math.cos(2 * math.pi * (time - start) / (end - start)))
                    density = scenario['base_density'] + (scenario['peak_density'] - scenario['base_density']) * peak_factor
            return density
        
        elif scenario.get('wave_frequency'):
            wave_time = time % scenario['wave_frequency']
            if wave_time < scenario['wave_duration']:
                wave_factor = 0.5 * (1 - math.cos(2 * math.pi * wave_time / scenario['wave_duration']))
                return scenario['base_density'] + (scenario['peak_density'] - scenario['base_density']) * wave_factor
            return scenario['base_density']
        
        elif scenario.get('cycle_frequency'):
            cycle_time = time % scenario['cycle_frequency']
            if cycle_time < scenario['cycle_duration']:
                return scenario['peak_density']
            return scenario['base_density']
        
        elif scenario.get('variation_frequency'):
            base = scenario['base_density']
            amplitude = scenario['variation_amplitude']
            frequency = scenario['variation_frequency']
            noise = 0.1 * (random.random() - 0.5)
            sine_component = amplitude * math.sin(2 * math.pi * time / frequency)
            return max(0.1, min(1.0, base + sine_component + noise))
        
        return 0.5
    
    def _manage_vehicle_population(self, target_density: float):
        """Manage vehicle population for density-based mode"""
        active_vehicles = [v for v in self.vehicles.values() if v.active]
        current_count = len(active_vehicles)
        
        if self.road_network:
            total_road_length = sum(road.geometry.get_length() for road in self.road_network.roads.values())
            road_length_km = total_road_length / 1000.0 if total_road_length > 0 else 1.0
        else:
            road_length_km = self.road_length / 1000.0
        
        if target_density <= 0.2:
            vehicles_per_km_per_direction = 30
        elif target_density <= 0.4:
            vehicles_per_km_per_direction = 60
        elif target_density <= 0.6:
            vehicles_per_km_per_direction = 120
        elif target_density <= 0.8:
            vehicles_per_km_per_direction = 180
        else:
            vehicles_per_km_per_direction = 240
        
        target_count = int(vehicles_per_km_per_direction * road_length_km * 2)
        variation = random.uniform(0.8, 1.2)
        target_count = int(target_count * variation)
        
        if current_count < target_count:
            spawn_rate = min(8, max(1, target_count - current_count))
            vehicles_to_spawn = min(spawn_rate, target_count - current_count)
            for _ in range(vehicles_to_spawn):
                if self.road_network:
                    self._spawn_network_vehicle()
                else:
                    self._spawn_vehicle()
        
        elif current_count > target_count * 1.3:
            vehicles_to_remove = min(5, current_count - target_count)
            if self.road_network:
                inactive_candidates = [v for v in active_vehicles if self._can_despawn_network(v)]
            else:
                inactive_candidates = [v for v in active_vehicles if self._can_despawn(v)]
            for vehicle in random.sample(inactive_candidates, min(vehicles_to_remove, len(inactive_candidates))):
                vehicle.active = False
    
    def _spawn_vehicle(self):
        """Original spawn vehicle method for density-based mode"""
        direction = random.choice(['forward', 'backward'])
        if direction == 'forward':
            lane = random.randint(1, self.num_lanes // 2)
            start_x = -50
        else:
            lane = random.randint(self.num_lanes // 2 + 1, self.num_lanes)
            start_x = self.road_length + 50
        
        vehicle_type = random.choices(
            ['car', 'truck', 'bus', 'motorcycle'], 
            weights=[0.75, 0.15, 0.05, 0.05]
        )[0]
        
        current_density = self._calculate_traffic_density(self.current_time)
        
        if current_density <= 0.2:
            speed_range = (2.5, 3.5)
        elif current_density <= 0.4:
            speed_range = (2.0, 3.0)
        elif current_density <= 0.6:
            speed_range = (1.5, 2.5)
        elif current_density <= 0.8:
            speed_range = (0.8, 1.8)
        else:
            speed_range = (0.2, 0.8)
        
        type_factors = {'truck': 0.85, 'bus': 0.8, 'motorcycle': 1.15, 'car': 1.0}
        factor = type_factors.get(vehicle_type, 1.0)
        initial_speed = random.uniform(speed_range[0] * factor, speed_range[1] * factor)
        
        vehicle_id = f'veh{self.vehicle_counter}'
        self.vehicle_counter += 1
        
        vehicle = Vehicle(vehicle_id, lane, start_x, initial_speed, direction, vehicle_type)
        self.vehicles[vehicle_id] = vehicle
    
    def _can_despawn(self, vehicle: Vehicle) -> bool:
        """Check if vehicle can be despawned (outside road boundaries)"""
        if hasattr(vehicle, 'direction'):
            if vehicle.direction == 'forward':
                return vehicle.x > self.road_length + 100
            else:
                return vehicle.x < -100
        return True
    
    def _handle_boundary_conditions(self, vehicle: Vehicle):
        """Handle vehicles reaching road boundaries"""
        if hasattr(vehicle, '_can_despawn') and callable(vehicle._can_despawn):
            if vehicle._can_despawn():
                vehicle.active = False
        elif self._can_despawn(vehicle):
            vehicle.active = False
    
    def _report_progress(self, i: int, total_steps: int, time: float, active_vehicles: List[Vehicle], 
                        current_density: float):
        """Report simulation progress"""
        progress = (i / total_steps) * 100
        
        print(f"Progress: {progress:.1f}% (Time: {time:.0f}s)")
        
        if self.operation_mode == 'road_network':
            print(f"   Network vehicles: {len(active_vehicles)}")
            if active_vehicles:
                avg_speed = np.mean([v.speed for v in active_vehicles]) * 3.6
                print(f"   Average speed: {avg_speed:.1f} km/h")
        else:
            print(f"   Vehicles: {len(active_vehicles)}")
            print(f"   Density: {current_density:.2f}")
        
        print("   " + "="*60)
    
    def _update_statistics(self, density: float, vehicles: List[Vehicle]):
        """Update simulation statistics"""
        self.density_history.append(float(density))
        self.vehicle_count_history.append(len(vehicles))
        
        if vehicles:
            avg_speed = np.mean([v.speed for v in vehicles])
            self.speed_history.append(float(avg_speed * 3.6))
        else:
            self.speed_history.append(0.0)
    
    def _draw_road_infrastructure(self):
        """Draw detailed road infrastructure (original method)"""
        if not hasattr(self, 'road_length') or not hasattr(self, 'num_lanes'):
            return
            
        lane_width = 3.7
        
        road_background = plt.Rectangle((0, 0), self.road_length, self.num_lanes * lane_width, 
                                       facecolor='#404040', alpha=0.8, zorder=0)
        self.ax.add_patch(road_background)
        
        for lane in range(self.num_lanes + 1):
            y = lane * lane_width
            if lane == 0 or lane == self.num_lanes:
                self.ax.axhline(y=y, color='white', linewidth=3, alpha=0.9, zorder=1)
            elif lane == self.num_lanes // 2:
                self.ax.axhline(y=y-0.1, color='yellow', linewidth=3, alpha=0.9, zorder=1)
                self.ax.axhline(y=y+0.1, color='yellow', linewidth=3, alpha=0.9, zorder=1)
            else:
                self.ax.axhline(y=y, color='white', linestyle='--', linewidth=2, alpha=0.7, zorder=1)
        
        if self.operation_mode == 'specific_defined_nodes':
            node_lane = self.traffic_config.get('lane_number', 1)
            lane_y = (node_lane - 1) * lane_width
            highlight = plt.Rectangle((0, lane_y), self.road_length, lane_width, 
                                    facecolor='lightblue', alpha=0.1, zorder=0.5)
            self.ax.add_patch(highlight)
    
    def _setup_statistics_display(self):
        """Setup real-time statistics displays"""
        self.stats_ax.set_title('Vehicle Statistics', fontsize=12, fontweight='bold')
        self.stats_ax.set_xlim(0, 100)
        self.stats_ax.set_ylim(0, 100)
        self.stats_ax.set_xlabel('Time Progress (%)')
        self.stats_ax.set_ylabel('Vehicles')
        
        self.speed_ax.set_title('Speed Distribution', fontsize=12, fontweight='bold')
        self.speed_ax.set_xlim(0, 150)
        self.speed_ax.set_ylim(0, 20)
        self.speed_ax.set_xlabel('Speed (km/h)')
        self.speed_ax.set_ylabel('Vehicle Count')
        
        self.vehicle_count_line, = self.stats_ax.plot([], [], 'b-', linewidth=2, label='Vehicle Count')
        
        if self.operation_mode == 'specific_defined_nodes' and self.traffic_config['node_mode'] == 'dynamic':
            self.node_distance_line, = self.stats_ax.plot([], [], 'r-', linewidth=2, label='Node Distance')
            self.stats_ax.legend()
        else:
            self.target_count_line, = self.stats_ax.plot([], [], 'r--', linewidth=2, label='Target Count')
            self.stats_ax.legend()
        
        self.speed_bins = np.arange(0, 151, 10)
        self.speed_bars = self.speed_ax.bar(self.speed_bins[:-1], np.zeros(len(self.speed_bins)-1), 
                                           width=8, alpha=0.7, color='green')
    
    def _draw_specific_node(self, node: SpecificNode):
        """Draw specific node with special styling (original method)"""
        node_config = {
            'car': {'color': '#FF1744', 'marker': 'D', 'size': 150, 'symbol': 'NODE'},
            'truck': {'color': '#D32F2F', 'marker': 'D', 'size': 200, 'symbol': 'N-TRK'},
            'bus': {'color': '#F57C00', 'marker': 'D', 'size': 180, 'symbol': 'N-BUS'},
            'motorcycle': {'color': '#8E24AA', 'marker': 'D', 'size': 120, 'symbol': 'N-MCY'}
        }
        
        config = node_config.get(node.vehicle_type, node_config['car'])
        x, y = node.get_position()
        
        node_plot = self.ax.scatter(x, y, c=config['color'], 
                                   marker=config['marker'], s=config['size'], 
                                   alpha=0.9, edgecolors='white', linewidth=3, zorder=5)
        
        speed_kmh = node.speed * 3.6
        if hasattr(node, 'phase') and node.config['node_mode'] == 'dynamic':
            label_text = f'{node.id}\n{speed_kmh:.0f} km/h\n{node.phase}'
        else:
            label_text = f'{node.id}\n{speed_kmh:.0f} km/h\nStatic'
            
        label = self.ax.text(x, y - 1.5, label_text, 
                           fontsize=10, ha='center', va='top', fontweight='bold',
                           bbox=dict(boxstyle="round,pad=0.3", facecolor='yellow', alpha=0.9),
                           zorder=5)
        self.vehicle_labels[node.id] = label
        
        if node.config['node_mode'] == 'dynamic' and hasattr(node, 'direction'):
            if node.direction == 'right':
                arrow = ''
                offset_x = node.length / 2
            elif node.direction == 'left':
                arrow = ''
                offset_x = -node.length / 2
            else:
                arrow = ''
                offset_x = 0
                
            direction_plot = self.ax.text(x + offset_x, y + 0.5, arrow, 
                                        fontsize=14, ha='center', va='center', 
                                        color='white', fontweight='bold', zorder=6)
            
            self.vehicle_plots[node.id] = [node_plot, direction_plot]
        else:
            self.vehicle_plots[node.id] = node_plot
    
    def _generate_statistics_report(self, output_file: str):
        """Generate comprehensive statistics report"""
        stats_file = output_file.replace('.xml', '_statistics.json')
        
        def convert_numpy(obj):
            if isinstance(obj, np.integer):
                return int(obj)
            elif isinstance(obj, np.floating):
                return float(obj)
            elif isinstance(obj, np.ndarray):
                return obj.tolist()
            return obj
        
        stats = {
            'simulation_info': {
                'duration': int(self.simulation_duration),
                'operation_mode': self.operation_mode,
                'traffic_config': self.traffic_config,
                'total_vehicles_spawned': int(self.vehicle_counter)
            },
            'traffic_statistics': {
                'avg_density': float(np.mean(self.density_history)) if self.density_history else 0.0,
                'max_density': float(np.max(self.density_history)) if self.density_history else 0.0,
                'min_density': float(np.min(self.density_history)) if self.density_history else 0.0,
                'avg_vehicle_count': float(np.mean(self.vehicle_count_history)) if self.vehicle_count_history else 0.0,
                'max_vehicle_count': int(np.max(self.vehicle_count_history)) if self.vehicle_count_history else 0,
                'min_vehicle_count': int(np.min(self.vehicle_count_history)) if self.vehicle_count_history else 0,
                'avg_speed_kmh': float(np.mean(self.speed_history)) if self.speed_history else 0.0,
                'min_speed_kmh': float(np.min(self.speed_history)) if self.speed_history else 0.0,
                'max_speed_kmh': float(np.max(self.speed_history)) if self.speed_history else 0.0
            }
        }
        
        if self.road_network:
            bounds = self.road_network.get_network_bounds()
            stats['simulation_info']['network_bounds'] = bounds
            stats['simulation_info']['road_count'] = len(self.road_network.roads)
            stats['simulation_info']['junction_count'] = len(self.road_network.junctions)
        else:
            stats['simulation_info']['road_length'] = int(getattr(self, 'road_length', 1000))
            stats['simulation_info']['num_lanes'] = int(getattr(self, 'num_lanes', 6))
        
        if self.operation_mode == 'specific_defined_nodes':
            node_stats = {
                'node_mode': self.traffic_config['node_mode'],
                'node_count': len(self.specific_nodes),
                'node_lane': self.traffic_config.get('lane_number', 1)
            }
            
            if self.traffic_config['node_mode'] == 'static':
                node_stats['node_positions'] = self.traffic_config['node_positions']
            elif self.traffic_config['node_mode'] == 'dynamic':
                node_stats['node_speed_kmh'] = self.traffic_config['node_speed_kmh']
                if self.node_distance_history:
                    node_stats['min_distance'] = float(np.min(self.node_distance_history))
                    node_stats['max_distance'] = float(np.max(self.node_distance_history))
                    node_stats['avg_distance'] = float(np.mean(self.node_distance_history))
            
            stats['node_statistics'] = node_stats
        
        def clean_for_json(obj):
            if isinstance(obj, dict):
                return {k: clean_for_json(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean_for_json(v) for v in obj]
            else:
                return convert_numpy(obj)
        
        stats = clean_for_json(stats)
        
        try:
            with open(stats_file, 'w') as f:
                json.dump(stats, f, indent=2)
            
            print(f"Statistics report saved to {stats_file}")
            self._print_summary_report(stats)
            
        except Exception as e:
            print(f"Warning: Could not save statistics report: {e}")
            self._print_basic_statistics()
    
    def _print_summary_report(self, stats: Dict):
        """Print comprehensive summary report"""
        print("\n  Simulation Summary:")
        print(f"   Operation Mode: {stats['simulation_info']['operation_mode']}")
        
        if self.operation_mode == 'road_network':
            print(f"   Network Type: {self.traffic_config.get('network_type', 'unknown')}")
            print(f"   Roads: {stats['simulation_info'].get('road_count', 0)}")
            print(f"   Junctions: {stats['simulation_info'].get('junction_count', 0)}")
        elif self.operation_mode == 'specific_defined_nodes':
            node_stats = stats.get('node_statistics', {})
            print(f"   Node Mode: {node_stats.get('node_mode', 'unknown')}")
            print(f"   Node Count: {node_stats.get('node_count', 0)}")
        else:
            print(f"   Average Density Factor: {stats['traffic_statistics']['avg_density']:.2f}")
            
        print(f"   Vehicle Count Range: {stats['traffic_statistics']['min_vehicle_count']} - {stats['traffic_statistics']['max_vehicle_count']}")
        print(f"   Speed Range: {stats['traffic_statistics']['min_speed_kmh']:.1f} - {stats['traffic_statistics']['max_speed_kmh']:.1f} km/h")
        print(f"   Total Vehicles Spawned: {stats['simulation_info']['total_vehicles_spawned']}")
        print(f"\n  Generation completed successfully!")
    
    def _print_basic_statistics(self):
        """Print basic statistics in case of JSON error"""
        print("  Basic Statistics:")
        if self.density_history:
            print(f"   Average Density Factor: {np.mean(self.density_history):.2f}")
        print(f"   Total Vehicles Spawned: {self.vehicle_counter}")
        if self.speed_history:
            print(f"   Average Speed: {np.mean(self.speed_history):.1f} km/h")

# ============================================================================
# EXAMPLE CONFIGURATIONS AND MAIN FUNCTION
# ============================================================================

def create_simple_intersection_demo():
    """Create demo for simple 4-way intersection"""
    print("Creating Simple Intersection Demo")
    print("=" * 40)
    
    traffic_config = FlexibleTrafficConfig.create_network_config(
        network_type='simple_intersection',
        vehicle_count=25,
        behavior_profile='normal',
        center_x=300,
        center_y=300,
        road_length=250
    )
    
    config = {
        'simulation_duration': 600,
        'time_step': 0.5,
        'enable_visualization': True,
        'traffic_config': traffic_config
    }
    
    print("Simple Intersection Configuration:")
    print(f"   - 4-way intersection at (300, 300)")
    print(f"   - Road length: 250m in each direction")
    print(f"   - Target vehicles: 25")
    print(f"   - Traffic lights enabled")
    print(f"   - Duration: 10 minutes")
    
    generator = ComprehensiveFCDGenerator(config)
    generator.generate_fcd('simple_intersection_demo.xml')

def create_highway_ramps_demo():
    """Create demo for highway with on/off ramps"""
    print("Creating Highway with Ramps Demo")
    print("=" * 40)
    
    traffic_config = FlexibleTrafficConfig.create_network_config(
        network_type='highway_with_ramps',
        vehicle_count=40,
        behavior_profile='normal',
        highway_length=1200
    )
    
    config = {
        'simulation_duration': 800,
        'time_step': 0.5,
        'enable_visualization': True,
        'traffic_config': traffic_config
    }
    
    print("Highway with Ramps Configuration:")
    print(f"   - Main highway: 1200m long, 3 lanes per direction")
    print(f"   - On-ramp and off-ramp with curved geometry")
    print(f"   - Target vehicles: 40")
    print(f"   - Higher speed limits on highway")
    print(f"   - Duration: ~13 minutes")
    
    generator = ComprehensiveFCDGenerator(config)
    generator.generate_fcd('highway_ramps_demo.xml')

def create_city_grid_demo():
    """Create demo for city grid network"""
    print("Creating City Grid Demo")
    print("=" * 40)
    
    traffic_config = FlexibleTrafficConfig.create_network_config(
        network_type='city_grid',
        vehicle_count=35,
        behavior_profile='conservative',
        grid_size=3,
        block_size=150
    )
    
    config = {
        'simulation_duration': 900,
        'time_step': 0.5,
        'enable_visualization': True,
        'traffic_config': traffic_config
    }
    
    print("City Grid Configuration:")
    print(f"   - 3x3 grid of intersections")
    print(f"   - Block size: 150m")
    print(f"   - All intersections have traffic lights")
    print(f"   - Target vehicles: 35")
    print(f"   - Conservative driving behavior")
    print(f"   - Duration: 15 minutes")
    
    generator = ComprehensiveFCDGenerator(config)
    generator.generate_fcd('city_grid_demo.xml')

def create_static_nodes_demo():
    """Create demo for static nodes (preserved from original)"""
    print("Creating Static Nodes Demo")
    print("=" * 40)
    
    traffic_config = FlexibleTrafficConfig.create_specific_nodes_config(
        node_mode='static',
        node_positions=(100.0, 300.0),
        lane_number=1,
        duration=500.0,
        node_types=('car', 'truck'),
        node_ids=('static_node_1', 'static_node_2'),
        road_length=500.0,
        enable_background_traffic=True,
        background_vehicle_count=8
    )
    
    config = {
        'simulation_duration': 500,
        'road_length': 500,
        'num_lanes_per_direction': 2,
        'time_step': 1.0,
        'enable_visualization': True,
        'traffic_config': traffic_config
    }
    
    print("Static Nodes Configuration:")
    print(f"   - Node 1 (car) at {traffic_config['node_positions'][0]}m")
    print(f"   - Node 2 (truck) at {traffic_config['node_positions'][1]}m")
    print(f"   - Lane: {traffic_config['lane_number']}")
    print(f"   - Duration: {traffic_config['duration']} seconds")
    print(f"   - Background traffic: {traffic_config['background_vehicle_count']} vehicles")
    
    generator = ComprehensiveFCDGenerator(config)
    generator.generate_fcd('static_nodes_demo.xml')

def create_dynamic_nodes_demo():
    """Create demo for dynamic nodes (preserved from original)"""
    print("Creating Dynamic Nodes Demo")
    print("=" * 40)
    
    traffic_config = FlexibleTrafficConfig.create_specific_nodes_config(
        node_mode='dynamic',
        node_speed_kmh=50.0,
        lane_number=2,
        duration=400.0,
        node_types=('car', 'car'),
        node_ids=('dynamic_node_A', 'dynamic_node_B'),
        road_length=500.0,
        enable_background_traffic=True,
        background_vehicle_count=12
    )
    
    config = {
        'simulation_duration': 400,
        'road_length': 500,
        'num_lanes_per_direction': 2,
        'time_step': 0.5,
        'enable_visualization': True,
        'traffic_config': traffic_config
    }
    
    print("Dynamic Nodes Configuration:")
    print(f"   - Node A starts at 0m, moves right")
    print(f"   - Node B starts at {traffic_config['road_length']}m, moves left")
    print(f"   - Speed: {traffic_config['node_speed_kmh']} km/h")
    print(f"   - Meeting point: {traffic_config['road_length']/2}m")
    print(f"   - Background traffic: {traffic_config['background_vehicle_count']} vehicles")
    
    generator = ComprehensiveFCDGenerator(config)
    generator.generate_fcd('dynamic_nodes_demo.xml')

def main():
    """Enhanced main function with road network examples"""
    
    print("Enhanced FCD Generator with Road Networks and Junctions")
    print("=" * 65)
    print("Available modes:")
    print("1. Road Network Modes (NEW):")
    print("   - Simple Intersection: 4-way intersection with traffic lights")
    print("   - Highway with Ramps: Highway with curved on/off ramps")
    print("   - City Grid: Grid network with multiple intersections")
    print("2. Original Modes:")
    print("   - Fixed Vehicle Count")
    print("   - Density-based Traffic")
    print("   - Specific Defined Node Positioning")
    print("=" * 65)
    
    # =========================================================================
    # CHOOSE YOUR CONFIGURATION MODE
    # =========================================================================
    
    # OPTION 1: NEW - SIMPLE INTERSECTION DEMO
    create_simple_intersection_demo()
    return
    
    # OPTION 2: NEW - HIGHWAY WITH RAMPS DEMO
    # create_highway_ramps_demo()
    # return
    
    # OPTION 3: NEW - CITY GRID DEMO
    # create_city_grid_demo()
    # return
    
    # OPTION 4: ORIGINAL - STATIC NODES DEMO
    # create_static_nodes_demo()
    # return
    
    # OPTION 5: ORIGINAL - DYNAMIC NODES DEMO
    # create_dynamic_nodes_demo()
    # return
    
    # =========================================================================
    # OPTION 6: ORIGINAL 45-CAR STRAIGHT ROAD CONFIGURATION
    # =========================================================================
    # Uncomment below for the original straight road configuration
    
    # traffic_config = FlexibleTrafficConfig.create_fixed_vehicle_config(
    #     vehicle_count=45,
    #     speed_range_kmh=(30, 120),
    #     vehicle_types={'car': 0.8, 'truck': 0.1, 'bus': 0.05, 'motorcycle': 0.05},
    #     lane_distribution='balanced',
    #     spawn_pattern='continuous',
    #     behavior_profile='normal',
    #     maintain_count=True,
    #     speed_variation=0.15
    # )
    # 
    # config = {
    #     'simulation_duration': 10000,
    #     'road_length': 500,
    #     'num_lanes_per_direction': 3,
    #     'time_step': 1.0,
    #     'enable_visualization': False,  # Set to True for animation
    #     'traffic_config': traffic_config
    # }
    # 
    # print("Original Configuration: 45 vehicles, 6 lanes, 10000 seconds")
    # generator = ComprehensiveFCDGenerator(config)
    # generator.generate_fcd('fcd_45cars_6lanes_10000s.xml')

if __name__ == "__main__":
    print("Welcome to the Enhanced FCD Generator with Road Networks!")
    print("\n" + "="*65)
    print("NEW FEATURES:")
    print("="*65)
    print("   Road Network Support:")
    print("   - Complex intersections with traffic lights")
    print("   - Highway segments with curved on/off ramps") 
    print("   - City grid networks with multiple junctions")
    print("   - Realistic vehicle routing and junction behavior")
    print("\n   Enhanced Vehicle Behavior:")
    print("   - Network-aware pathfinding")
    print("   - Junction-specific speed adaptation")
    print("   - Road-type specific speed limits")
    print("\n   Advanced Visualization:")
    print("   - Road network infrastructure display")
    print("   - Junction and traffic light indicators")
    print("   - Curved road geometry rendering")
    print("="*65)
    print("\nCurrently Running: Simple Intersection Demo")
    print("   4-way intersection with traffic lights and realistic vehicle routing")
    print("\nTo Switch Modes:")
    print("   Comment current demo and uncomment desired demo in main()")
    print("   Available: highway_ramps, city_grid, static_nodes, dynamic_nodes")
    print("="*65)
    print("\nStarting Simple Intersection Demo...")
    
    main()
